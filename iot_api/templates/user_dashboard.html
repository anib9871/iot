<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>IoT Multi-Level Dashboard</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet">
<link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
<style>
body { margin:0; padding-top:70px; display:flex; }
.navbar { background: linear-gradient(90deg, #0d6efd, #0a58ca); box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
.navbar .nav-link { color:#fff !important; }
.sidebar { width:260px; background:#f8f9fa; border-right:1px solid #dee2e6; padding:20px; position:fixed; top:70px; bottom:0; display:flex; flex-direction:column; overflow:hidden; }
.sidebar-content { overflow-y:auto; flex:1; padding-right:5px; }
.sidebar h5 { font-weight:600; margin-bottom:15px; }
.sidebar .form-select { margin-bottom:15px; border-radius:8px; }
.sidebar .summary-card { min-height:60px; padding:2px 4px; margin-bottom:10px; font-size:0.8rem; display:flex; flex-direction:column; justify-content:center; align-items:center; border-radius:12px; color:#fff; }
.sidebar .summary-card i { font-size:1.4rem; margin-bottom:4px; }
.sidebar .summary-card h6 { font-size:0.85rem; margin-bottom:2px; }
.sidebar .summary-card p { font-size:0.9rem; margin:0; font-weight:600; }
.content { margin-left:260px; padding:20px; flex:1; overflow-x:hidden; }
#deviceTypeCards { display:flex; flex-wrap:wrap; gap:15px; justify-content:center; margin-top:50px; }
.device-type-card { flex:1 1 calc(33.33% - 10px); max-width:calc(33.33% - 10px); height:120px; background:linear-gradient(135deg,#0d6efd,#6610f2); color:white; display:flex; flex-direction:column; justify-content:center; align-items:center; border-radius:12px; box-shadow:0 4px 12px rgba(0,0,0,0.15); cursor:pointer; transition:0.3s; }
.device-type-card:hover { transform:translateY(-5px); box-shadow:0 6px 15px rgba(0,0,0,0.2); }
.device-type-card.disabled { background:#e0e0e0 !important; color:#888 !important; cursor:not-allowed; }
.device-card { padding:10px; border-radius:12px; color:white; text-align:center; box-shadow:0 4px 12px rgba(0,0,0,0.15); margin-bottom:10px; max-width:300px; width:100%; }
.device-card.bg-success { background:#fff; border:2px solid #28a745; color:#000; min-height:60px; max-width:400px; }
.device-card.bg-danger { background:#fff; border:2px solid #dc3545; color:#000; min-height:60px; max-width:400px; }
#deviceDetailsContainer { display:none; }
#deviceList { display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-start; align-items: flex-start; margin-bottom: 20px; }
#deviceList .device-card { flex: 1 1 200px; max-width: 250px; min-width: 180px; }
#alarmLog tr td { vertical-align:middle; }
/* Hover effect for device cards */
.device-card {
  position: relative;
  overflow: hidden;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.device-card:hover {
  transform: translateY(-3px);
  box-shadow: 0 6px 15px rgba(0,0,0,0.2);
}

/* Overlay text on hover */
.device-card::after {
  content: "View Graph";
  position: absolute;
  inset: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  color: #fff;
  font-weight: 600;
  font-size: 0.9rem;
  background: rgba(0, 0, 0, 0.55);
  opacity: 0;
  transition: opacity 0.3s ease;
  border-radius: 12px;
}

.device-card:hover::after {
  opacity: 1;
}

</style>
</head>
<body>

<nav class="navbar navbar-expand-lg navbar-dark fixed-top">
<div class="container-fluid">
  <a class="navbar-brand" href="#">IoT Dashboard</a>
  <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
    <span class="navbar-toggler-icon"></span>
  </button>
  <div class="collapse navbar-collapse justify-content-end" id="navbarNav">
    <ul class="navbar-nav">
      <li class="nav-item"><a class="nav-link" href="#" onclick="logout()">Logout</a></li>
    </ul>
  </div>
</div>
</nav>

<div class="sidebar">
  <div class="sidebar-content">
    <h5>Filters</h5>
    <label>Organization Name</label>
    <select id="organizationSelect" class="form-select mb-3"><option value="">Select Organization</option></select>
    <label>Centre Name</label>
    <select id="centreSelect" class="form-select mb-3"><option value="">Select Centre</option></select>

    <label for="startDateTime">Start Date & Time</label>
    <input type="datetime-local" id="startDateTime" class="form-control mb-2">
    <label for="endDateTime">End Date & Time</label>
    <input type="datetime-local" id="endDateTime" class="form-control mb-3">
    <button class="btn btn-sm btn-warning w-100 mt-2 mb-3" onclick="clearFilters()">Clear Filters</button>
    <h5>Summary</h5>
    <div id="summaryCards">
      <div class="summary-card bg-primary text-center mb-3">
        <i class="bi bi-hdd-network"></i><h6>Total Devices</h6><p id="totalDevices" class="fs-5 fw-bold">0</p>
      </div>
      <div class="summary-card bg-success text-center mb-3">
        <i class="bi bi-check-circle"></i><h6>Active Devices</h6><p id="activeDevices" class="fs-5 fw-bold">0</p>
      </div>
      <div class="summary-card bg-danger text-center mb-3">
        <i class="bi bi-x-circle"></i><h6>Offline Devices</h6><p id="offlineDevices" class="fs-5 fw-bold">0</p>
      </div>
    </div>
  </div>
</div>

<div class="content">
  <div id="deviceTypeCards" class="d-flex flex-wrap gap-3"></div>

  <div id="deviceDetailsContainer">
    <button class="btn btn-sm btn-secondary mb-3" onclick="backToDashboard()">‚Üê Back</button>
    <h4 id="deviceTypeTitle"></h4>
    <div id="deviceList" class="mb-3"></div>        
    <div style="max-width:700px;margin:auto;display:flex;gap:15px;align-items:flex-start;">
      <div style="flex:0 0 150px;display:flex;flex-direction:column;gap:10px;margin-left:-200px;">
        <div style="max-width:250px;background:#dc3545;color:#fff;border-radius:10px;padding:8px;text-align:center;" class="mb-3">
          <h6 style="font-size:0.8rem;margin-bottom:4px;">Total Alarms (24h)</h6>
          <p id="alarm24h" class="fs-6 fw-bold">0</p>
        </div>
      </div>
      <div style="flex:1;background:#fff;border-radius:15px;box-shadow:0 4px 15px rgba(0,0,0,0.1);padding:15px;">
        <canvas id="deviceGraph" style="max-height:300px;"></canvas>
      </div>
    </div>

    <h5 class="mt-4 d-flex justify-content-between align-items-center">
      Alarm Log  <span class="badge bg-danger">Active Alarms   <span class="badge bg-danger" id="activeAlarmCount">0</span></span>
    </h5>
    <table class="table table-striped">
      <thead><tr><th>Device</th><th>Alarm</th><th>Time</th><th>Status</th></tr></thead>
      <tbody id="alarmLog"></tbody>
    </table>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js"></script>
<script>
const BASE_URL = "https://iot-production-c2ae.up.railway.app";
const API = {
  masterorganizations: BASE_URL + "/api/masterorganization/",
  mastercentre: BASE_URL + "/api/mastercentre/",
  devicecategory: BASE_URL + "/api/devicecategory/",
  masterDevices: BASE_URL + "/api/masterdevice/",
  devicereadinglog: BASE_URL + "/api/devicereadinglog/",
  devicealarmlog: BASE_URL + "/api/devicealarmlog/",
  userorganizationcentrelink: BASE_URL + "/api/userorganizationcentrelink/",
  masteruom: BASE_URL + "/api/masteruom/",
  masterparameter: BASE_URL + "/api/masterparameter/",
};

let centreData=[], allDevices=[], allCategories=[], currentCentreId=null, currentUser=null;
let currentCategoryId=null, liveUpdateInterval=null;
window.currentDeviceGraphDeviceId = null;

// ------------- LOAD DATA -------------
async function loadOrganizations(){
  try{
    const userRes = await fetch(BASE_URL + "/api/currentuser/");
    currentUser = await userRes.json();
    const linkRes = await fetch(API.userorganizationcentrelink + `?USER_ID=${currentUser.USER_ID}`);
    const userLinks = await linkRes.json();
    const allowedOrgIds = userLinks.map(l => l.ORGANIZATION_ID);

    const res = await fetch(API.masterorganizations);
    const orgs = await res.json();
    const orgSelect = document.getElementById("organizationSelect");
    orgSelect.innerHTML = '<option value="">Select Organization</option>';
    orgs.filter(o => allowedOrgIds.includes(o.ORGANIZATION_ID))
        .forEach(o => orgSelect.innerHTML += `<option value="${o.ORGANIZATION_ID}">${o.ORGANIZATION_NAME}</option>`);
    
    if(userLinks.length>0){
      orgSelect.value = userLinks[0].ORGANIZATION_ID;
      await loadCentres(orgSelect.value, true, userLinks[0].CENTRE_ID);
    }
  }catch(err){ console.error(err);}
}

async function loadCentres(orgId, auto=false, userCentreId=null){
  const centreSelect = document.getElementById("centreSelect");
  centreSelect.innerHTML = '<option value="">Select Centre</option>';
  if(!orgId) return;
  try {
    if(!centreData.length){
      const res = await fetch(API.mastercentre);
      centreData = await res.json();
    }
    let filtered = centreData.filter(c => c.ORGANIZATION_ID == orgId);
    if(userCentreId) filtered = filtered.filter(c => c.CENTRE_ID == userCentreId);
    filtered.forEach(c => { centreSelect.innerHTML += `<option value="${c.CENTRE_ID}">${c.CENTRE_NAME}</option>`; });
    if(auto && userCentreId) {
      centreSelect.value = userCentreId;
      loadDevices(userCentreId);
    }
  } catch(err) { console.error(err); }
}

async function loadDevices(centreId){
  currentCentreId=centreId;
  try{
    const res = await fetch(API.masterDevices);
    allDevices = (await res.json()).filter(d=>d.CENTRE_ID==centreId);
    const catRes = await fetch(API.devicecategory);
    allCategories = await catRes.json();
    updateSummary();
    showCategoryCards();
  }catch(err){console.error(err);}
}

// ------------- DASHBOARD UI -------------
function clearFilters(){
  document.getElementById("startDateTime").value = "";
  document.getElementById("endDateTime").value = "";
  if(currentCategoryId) openDeviceDashboard(currentCategoryId);
}

function updateSummary(){
    const total = allDevices.length;
    const active = allDevices.filter(d => d.status === "active").length;
    const offline = total - active;

    document.getElementById("totalDevices").textContent = total;
    document.getElementById("activeDevices").textContent = active;
    document.getElementById("offlineDevices").textContent = offline;
}


function showCategoryCards(){
  document.getElementById("deviceDetailsContainer").style.display="none";
  const container=document.getElementById("deviceTypeCards");
  container.innerHTML="";
  allCategories.forEach(cat=>{
    const devicesOfCat = allDevices.filter(d=>d.CATEGORY_ID===cat.CATEGORY_ID);
    const count = devicesOfCat.length;
    const card = document.createElement("div");
    card.className="device-type-card";
    card.innerHTML=`<h6>${cat.CATEGORY_NAME}</h6><strong>${count}</strong>`;
    if(count>0) card.onclick=()=>openDeviceDashboard(cat.CATEGORY_ID);
    else card.classList.add('disabled');
    container.appendChild(card);
  });
}

function backToDashboard(){ 
  showCategoryCards(); 
  if(liveUpdateInterval) clearInterval(liveUpdateInterval);
  window.currentDeviceGraphDeviceId = null;
}

function logout(){ fetch('/logout/').then(()=>window.location='/login/'); }

// ------------- LIVE UPDATES -------------
function startLiveUpdates(categoryId){
    if(liveUpdateInterval) clearInterval(liveUpdateInterval);
    updateDashboardLive(categoryId);
    liveUpdateInterval = setInterval(()=>updateDashboardLive(categoryId),10000);
}

// ----------- DEVICE STATUS FIX (VOC FRIENDLY) -----------
// ------------------- DEVICE LIVE STATUS FIX -------------------
async function updateDashboardLive(categoryId){
    if(!currentCentreId) return;

    const devices = allDevices.filter(d => d.CATEGORY_ID === categoryId);
    const [masterparameter, masteruom] = await Promise.all([
        fetch(API.masterparameter).then(r=>r.json()),
        fetch(API.masteruom).then(r=>r.json())
    ]);

    const readingsDataRaw = await (await fetch(API.devicereadinglog + `?centre=${currentCentreId}&category=${categoryId}`)).json();
    const now = new Date();

    devices.forEach(device=>{
        // 1Ô∏è‚É£ Filter readings for this device only
        const deviceReadings = readingsDataRaw
            .filter(r => r.DEVICE_ID === device.DEVICE_ID)
            .sort((a,b)=>new Date(a.READING_DATE+'T'+a.READING_TIME) - new Date(b.READING_DATE+'T'+b.READING_TIME));
        const latestReading = deviceReadings[deviceReadings.length-1];

        // 2Ô∏è‚É£ Determine online/offline
// 2Ô∏è‚É£ Determine online/offline
let status = "offline", displayVal = "Offline";

if (deviceReadings.length > 0) {
    // Filter only VOC readings for VOC devices
    const vocOnly = deviceReadings.filter(r => {
        const param = masterparameter.find(p => String(p.PARAMETER_ID) === String(r.PARAMETER_ID));
        return param && param.PARAMETER_NAME.toLowerCase().includes("voc");
    });

    // Use latest VOC reading (if exists)
    const latestVoc = vocOnly[vocOnly.length - 1];
    const latestReading = latestVoc || deviceReadings[deviceReadings.length - 1]; // fallback

    const readingTime = new Date(latestReading.READING_DATE + 'T' + latestReading.READING_TIME);
    if (now - readingTime <= 15 * 60 * 1000) {
        status = "active";

        const param = masterparameter.find(p => String(p.PARAMETER_ID) === String(latestReading.PARAMETER_ID));
        const uomObj = param ? masteruom.find(u => String(u.UOM_ID) === String(param.UOM_ID)) : null;
        const uom = uomObj?.UOM_NAME || '';

        displayVal = Math.round(parseFloat(latestReading.READING)) + ' ' + uom;

    }
}

device.status = status;


        // 3Ô∏è‚É£ Update device card
        const el = document.getElementById(`currentTemp_${device.DEVICE_ID}`);
        if(!el) return;
        el.textContent = displayVal;
        el.parentElement.className = status==="active" ? "device-card bg-success" : "device-card bg-secondary";
    });

    // 4Ô∏è‚É£ Update summary
    const total = devices.length;
    const active = devices.filter(d=>d.status==="active").length;
    document.getElementById("totalDevices").textContent = total;
    document.getElementById("activeDevices").textContent = active;
    document.getElementById("offlineDevices").textContent = total - active;

    // 5Ô∏è‚É£ Refresh graph & alarms if a device is open
    if(window.currentDeviceGraphDeviceId){
        const currentDevice = allDevices.find(d=>d.DEVICE_ID===window.currentDeviceGraphDeviceId);
        if(currentDevice) loadDeviceReadings(currentDevice);
    }


    // Refresh chart & alarms for current device
    if(window.currentDeviceGraphDeviceId){
        loadDeviceReadings(allDevices.find(d=>d.DEVICE_ID===window.currentDeviceGraphDeviceId));
    }

    // üîÅ Auto-refresh graph every 30 minutes (1800000 ms)
if (window.deviceGraphRefreshInterval) clearInterval(window.deviceGraphRefreshInterval);

window.deviceGraphRefreshInterval = setInterval(() => {
    if (window.currentDeviceGraphDeviceId) {
        const currentDevice = allDevices.find(d => d.DEVICE_ID === window.currentDeviceGraphDeviceId);
        if (currentDevice) {
            console.log("‚è≥ Auto-refreshing graph for:", currentDevice.DEVICE_NAME);
            loadDeviceReadings(currentDevice);
        }
    }
}, 30 * 60 * 1000); // 30 minutes


    // Update summary accurately device-wise
    updateSummary();
}


// ------------- DEVICE DASHBOARD -------------
async function openDeviceDashboard(categoryId){
    currentCategoryId = categoryId;
    document.getElementById("deviceTypeCards").innerHTML="";
    document.getElementById("deviceDetailsContainer").style.display="block";
    const category = allCategories.find(c=>c.CATEGORY_ID===categoryId);
    document.getElementById("deviceTypeTitle").textContent = category?.CATEGORY_NAME || categoryId;

    const devices = allDevices.filter(d=>d.CATEGORY_ID===categoryId);
    const deviceList = document.getElementById("deviceList");
    deviceList.innerHTML = "";

    devices.forEach(device=>{
        const div = document.createElement("div");
        div.className="device-card bg-secondary";
        div.style.cursor="pointer";
        div.id = `card_${device.DEVICE_ID}`;
        div.innerHTML = `<h6>${device.DEVICE_NAME}</h6><p id="currentTemp_${device.DEVICE_ID}" style="font-weight:600;">Loading...</p>`
        ;
        div.addEventListener("click",()=>loadDeviceReadings(device));
        deviceList.appendChild(div);
    });

    startLiveUpdates(categoryId);
}

async function loadDeviceReadings(device){
    window.currentDeviceGraphDeviceId = device.DEVICE_ID;
    const masterparameter = await fetch(API.masterparameter).then(r=>r.json());
    const masteruom = await fetch(API.masteruom).then(r=>r.json());
    const startInput = document.getElementById("startDateTime").value;
    const endInput = document.getElementById("endDateTime").value;

    // üîπ Default to last 24 hours
    let start = startInput ? new Date(startInput) : new Date(Date.now() - 24 * 60 * 60 * 1000);
    let end = endInput ? new Date(endInput) : new Date();
    const now = new Date();

    const readingsDataRaw = await (await fetch(API.devicereadinglog + `?centre=${currentCentreId}&category=${currentCategoryId}`)).json();

    // üîπ Filter readings only for this device and within last 24 hours
// üîπ Filter readings only for this device and within last 24 hours
// üîπ Filter readings for this device (within selected time range)
let dataPoints = readingsDataRaw
    .filter(r => r.DEVICE_ID === device.DEVICE_ID)
    .map(r => ({
        x: new Date(r.READING_DATE + 'T' + r.READING_TIME),
        y: parseFloat(r.READING),
        paramId: r.PARAMETER_ID
    }))
    .filter(p => p.x >= start && p.x <= end);

// üîπ Detect if this category/device is VOC type
const category = allCategories.find(c => c.CATEGORY_ID === currentCategoryId);
const isVOC = category?.CATEGORY_NAME?.toLowerCase().includes("voc");

// üîπ If VOC category ‚Üí keep only VOC readings
if (isVOC) {
    const vocParam = masterparameter.find(p => p.PARAMETER_NAME.toLowerCase().includes("voc"));
    if (vocParam) {
        dataPoints = dataPoints.filter(dp => String(dp.paramId) === String(vocParam.PARAMETER_ID));
    }
}


    // üîπ Identify parameter name (VOC / Refricheck)
    const param = masterparameter.find(p => String(p.PARAMETER_ID) === String(dataPoints[0]?.paramId));
    const paramName = param?.PARAMETER_NAME?.toLowerCase() || "";

    // üîπ Cap readings (limit Y values)
    dataPoints.forEach(p => {
        if (paramName.includes("voc") && p.y > 2000) p.y = 2000;
        if (paramName.includes("refricheck") && p.y > 15) p.y = 15;
    });

    // üîπ Update current value
    const latest = dataPoints[dataPoints.length - 1];
    const el = document.getElementById(`currentTemp_${device.DEVICE_ID}`);
if (latest) {
    const uomObj = param ? masteruom.find(u => String(u.UOM_ID) === String(param.UOM_ID)) : null;
    const uom = uomObj?.UOM_NAME || '';
    const readingVal = parseFloat(latest.y);

    // üîπ Fetch thresholds from masterparameter
    const lower = parseFloat(param?.LOWER_THRESHOLD ?? 0);
    const mid = parseFloat(param?.THRESHOLD ?? 0);
    const upper = parseFloat(param?.UPPER_THRESHOLD ?? 0);

    // üîπ Decide color
    let colorClass = "bg-success"; // default green
    if (!isNaN(readingVal)) {
        if (upper && readingVal > upper) colorClass = "bg-danger"; // High
        else if (lower && readingVal < lower) colorClass = "bg-warning"; // Low
        else colorClass = "bg-success"; // Normal
    }

    // üîπ Update UI
    el.textContent = Math.round(readingVal) + ' ' + uom;
    el.parentElement.className = `device-card ${colorClass}`;
    device.status = "active";
} else {
    el.textContent = "Offline";
    el.parentElement.className = "device-card bg-secondary";
    device.status = "offline";
}


    // üîπ Draw line chart
    const ctx = document.getElementById("deviceGraph").getContext('2d');
    if (window.deviceChart) window.deviceChart.destroy();
    window.deviceChart = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [{
                label: device.DEVICE_NAME,
                data: dataPoints,
                borderColor: '#007bff',
                backgroundColor: 'rgba(0, 123, 255, 0.1)',
                borderWidth: 2,
                tension: 0.4,
                fill: false,
                pointRadius: 0,
                pointHoverRadius: 0
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { tooltip: { mode: 'index', intersect: false }, legend: { display: true, position: 'top' } },
            scales: {
                x: { type: 'time', time: { tooltipFormat: 'dd-MM-yyyy HH:mm' }, title: { display: true, text: 'Time' } },
                y: {
                    beginAtZero: true,
                    title: { display: true, text: 'Reading Value' },
                    // üîπ Set dynamic max based on parameter
                    suggestedMax: paramName.includes("voc") ? 2000 : (paramName.includes("refricheck") ? 15 : undefined)
                }
            }
        }
    });

    // üîπ Update alarms
    const alarmsRaw = await (await fetch(API.devicealarmlog + `?centre=${currentCentreId}&category=${currentCategoryId}`)).json();
   // üîπ Detect VOC category
const isVOCDevice = allCategories.find(c => c.CATEGORY_ID === currentCategoryId)?.CATEGORY_NAME?.toLowerCase().includes("voc");

// üîπ Filter alarms
let alarms = alarmsRaw.filter(a => a.DEVICE_ID === device.DEVICE_ID);
if (isVOCDevice) {
    alarms = alarms.filter(a => {
        const param = masterparameter.find(p => String(p.PARAMETER_ID) === String(a.PARAMETER_ID));
        return param && param.PARAMETER_NAME.toLowerCase().includes("voc");
    });
}
alarms = alarms.sort((a, b) => new Date(b.ALARM_DATE + 'T' + b.ALARM_TIME) - new Date(a.ALARM_DATE + 'T' + a.ALARM_TIME));

    const alarmBody = document.getElementById("alarmLog");
    alarmBody.innerHTML = "";
    let activeCount = 0;
    alarms.forEach(a => {
        const isActive = a.IS_ACTIVE === 1;
        if (isActive) activeCount++;
        alarmBody.innerHTML += `
            <tr>
                <td>${device.DEVICE_NAME}</td>
                <td>${a.READING ?? '-'}</td>
                <td>${a.ALARM_DATE} ${a.ALARM_TIME}</td>
                <td><span class="badge ${isActive ? 'bg-danger' : 'bg-success'}">
                    ${isActive ? 'Active' : 'Resolved'}
                </span></td>
            </tr>`;
    });
    document.getElementById("alarm24h").textContent =
        alarms.filter(a => now - new Date(a.ALARM_DATE + 'T' + a.ALARM_TIME) <= 24 * 60 * 60 * 1000).length;
    document.getElementById("activeAlarmCount").textContent = activeCount;

    // üîÅ Auto-refresh graph every 30 minutes (1800000 ms)
if (window.deviceGraphRefreshInterval) clearInterval(window.deviceGraphRefreshInterval);

window.deviceGraphRefreshInterval = setInterval(() => {
    if (window.currentDeviceGraphDeviceId) {
        const currentDevice = allDevices.find(d => d.DEVICE_ID === window.currentDeviceGraphDeviceId);
        if (currentDevice) {
            console.log("‚è≥ Auto-refreshing graph for:", currentDevice.DEVICE_NAME);
            loadDeviceReadings(currentDevice);
        }
    }
}, 30 * 60 * 1000); // 30 minutes

    
    updateSummary();

}

// Event listeners
document.getElementById("startDateTime").addEventListener("change",()=>{ if(currentCategoryId) updateDashboardLive(currentCategoryId); });
document.getElementById("endDateTime").addEventListener("change",()=>{ if(currentCategoryId) updateDashboardLive(currentCategoryId); });
document.getElementById("organizationSelect").addEventListener("change",e=>loadCentres(e.target.value));
document.getElementById("centreSelect").addEventListener("change",e=>loadDevices(e.target.value));

// Initialize
(async function(){ await loadOrganizations(); })();
</script>
</body>
</html>
